/**
 * Gradle script to patch the Vico library with NaN handling fixes using bytecode manipulation
 *
 * This script uses ASM to modify the compiled bytecode of LineCartesianLayer.class
 * to add NaN checks before roundToInt() calls, preventing the crash.
 */

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.ow2.asm:asm:9.6'
        classpath 'org.ow2.asm:asm-commons:9.6'
        classpath 'org.ow2.asm:asm-util:9.6'
    }
}

import org.objectweb.asm.*
import org.objectweb.asm.commons.*
import static org.objectweb.asm.Opcodes.*

configurations {
    vicoCoreOriginal
}

dependencies {
    vicoCoreOriginal "com.patrykandpatrick.vico:core:${vico_version}"
}

ext {
    vicoExtractedDir = file("${buildDir}/vico-extracted")
    vicoPatchedJar = file("${buildDir}/libs/vico-core-${vico_version}-patched.jar")
    targetClass = 'com/patrykandpatrick/vico/core/cartesian/layer/LineCartesianLayer.class'
}

task extractVicoJar {
    description = 'Extract Vico core JAR'
    inputs.files(configurations.vicoCoreOriginal)
    outputs.dir(vicoExtractedDir)

    doLast {
        delete vicoExtractedDir
        vicoExtractedDir.mkdirs()

        configurations.vicoCoreOriginal.each { file ->
            copy {
                from zipTree(file)
                into vicoExtractedDir
            }
        }
        logger.lifecycle("✓ Extracted Vico JAR to ${vicoExtractedDir}")
    }
}

task patchVicoClass {
    description = 'Patch LineCartesianLayer bytecode to add NaN checks'
    dependsOn extractVicoJar
    inputs.dir(vicoExtractedDir)
    outputs.dir(vicoExtractedDir)

    doLast {
        def classFile = file("${vicoExtractedDir}/${targetClass}")
        if (!classFile.exists()) {
            logger.error("Class file not found: ${classFile}")
            throw new GradleException("Cannot find LineCartesianLayer.class")
        }

        logger.lifecycle("Patching ${classFile}...")

        // Read the original class
        def classBytes = classFile.bytes

        // Create a ClassReader and ClassWriter
        def reader = new ClassReader(classBytes)
        def writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES)

        // Create a visitor that will add NaN checks
        def visitor = new ClassVisitor(ASM9, writer) {
            @Override
            MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
                def mv = super.visitMethod(access, name, descriptor, signature, exceptions)

                // Only patch the updateMarkerTargets method
                if (name == 'updateMarkerTargets' &&
                    descriptor == '(Lcom/patrykandpatrick/vico/core/cartesian/layer/LineCartesianLayerModel$Entry;FFLandroid/graphics/Bitmap;)V') {

                    logger.lifecycle("✓ Found updateMarkerTargets method, injecting NaN checks...")

                    return new AdviceAdapter(ASM9, mv, access, name, descriptor) {
                        Label boundaryCheckLabel
                        int instructionCount = 0

                        @Override
                        void visitInsn(int opcode) {
                            instructionCount++

                            // After the first RETURN (bounds check), inject NaN checks
                            if (opcode == RETURN && instructionCount < 20) {
                                // This is the bounds check return, keep it
                                super.visitInsn(opcode)

                                // Now inject NaN checks right after
                                // Check canvasX.isNaN()
                                super.visitVarInsn(FLOAD, 2) // Load canvasX parameter
                                super.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "isNaN", "(F)Z", false)
                                Label notNaNX = new Label()
                                super.visitJumpInsn(IFEQ, notNaNX) // If false (not NaN), jump
                                super.visitInsn(RETURN) // If true (is NaN), return
                                super.visitLabel(notNaNX)

                                // Check canvasY.isNaN()
                                super.visitVarInsn(FLOAD, 3) // Load canvasY parameter
                                super.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "isNaN", "(F)Z", false)
                                Label notNaNY = new Label()
                                super.visitJumpInsn(IFEQ, notNaNY) // If false (not NaN), jump
                                super.visitInsn(RETURN) // If true (is NaN), return
                                super.visitLabel(notNaNY)

                                // Don't call super.visitInsn again since we already did
                                return
                            }

                            super.visitInsn(opcode)
                        }
                    }
                }

                return mv
            }
        }

        // Apply the transformation
        reader.accept(visitor, 0)

        // Write the patched class back
        classFile.bytes = writer.toByteArray()
        logger.lifecycle("✓ Successfully patched LineCartesianLayer.class with NaN checks")
    }
}

task createPatchedVicoJar(type: Jar) {
    description = 'Create patched Vico JAR with NaN fix'
    dependsOn patchVicoClass
    archiveBaseName = 'vico-core'
    archiveVersion = "${vico_version}-patched"
    destinationDirectory = file("${buildDir}/libs")
    from vicoExtractedDir

    doLast {
        logger.lifecycle("✓ Created patched Vico JAR: ${archiveFile.get().asFile.name}")
    }
}

// Use the patched JAR instead of the original
configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute module('com.patrykandpatrick.vico:core') using files(vicoPatchedJar) because 'Using patched version with NaN fix'
    }
}

// Ensure the patched JAR is built before compilation
preBuild.dependsOn createPatchedVicoJar
