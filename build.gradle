// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    ext {
        controlx2_version = "1.0.0-20251127"
        pumpx2_version = "1.7.5"
        use_local_pumpx2 = System.properties.getOrDefault('use_local_pumpx2', 'false') == 'true'
        if (!use_local_pumpx2) {
            Properties properties = new Properties()
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            use_local_pumpx2 = (properties.getProperty('use_local_pumpx2') ?: '') == 'true'
        }
        m2_repository = "${System.properties['user.home']}/.m2/repository"
        compose_version = '1.7.8'
        androidx_watchface_version = '1.2.1'
        kotlin_version = "2.0.0"
    }
    dependencies {
        classpath 'hu.supercluster:paperwork-plugin:1.2.7'
    }
}

plugins {
    id 'com.android.application' version '9.0.0-beta05' apply false
    id 'com.android.library' version '9.0.0-beta05' apply false
    id 'org.jetbrains.kotlin.android' version '2.0.0' apply false
    id 'org.jetbrains.kotlin.plugin.compose' version '2.0.0' apply false
    id 'app.cash.paparazzi' version '1.3.4' apply false
}

// Connected Android tests can hang on CI when Gradle attempts to exercise
// every Android subproject (including dependency helper modules that are not
// meant to run instrumentation tests in automation). The coverage workflow only
// needs the mobile app's device tests, so disable the other connected test
// tasks when we know we're running in CI. This prevents the emulator job from
// waiting forever for tests that will never finish.
if (System.getenv("CI") == "true") {
    subprojects { subproject ->
        if (subproject.name != "mobile") {
            subproject.afterEvaluate {
                subproject.tasks.matching { task ->
                    task.name.startsWith("connected") && task.name.endsWith("AndroidTest")
                }.configureEach { task ->
                    task.enabled = false
                    if (task.project == subproject) {
                        task.logger.lifecycle("Skipping ${subproject.path}:${task.name} on CI")
                    }
                }
            }
        }
    }
}
